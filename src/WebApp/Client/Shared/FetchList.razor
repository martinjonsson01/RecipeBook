@using System.Net
@using Newtonsoft.Json
@using RecipeBook.Core.Application.Logic
@using System.Collections.ObjectModel
@using System.Collections.Specialized
@using System.Text
@using System.Collections

@typeparam TItem

@inject HttpClient _http

@Header
@if (_items is not null)
{
    @ItemsTemplate(_items)
    <button type="button" class="btn btn-outline-secondary" 
            @onclick="_ => _items.Add(CreateNewItem(_items.Count + 1))">@CreateNewItemText</button>
}
else if (_responseStatus is null)
{
    @LoadingTemplate
}
else if (_responseStatus == HttpStatusCode.NotFound)
{
    @NotFoundTemplate
}

@* ReSharper disable twice InconsistentNaming *@
@* ReSharper disable twice UnusedParameter.Local *@
@code {
#nullable enable

    [Parameter]
    public string Url { get; set; } = string.Empty;

    [Parameter]
    public RenderFragment Header { get; set; } = null!;

    [Parameter]
    public EventCallback<(string, LoadStatus)> SetSaving { get; set; }

    [Parameter]
    public Func<int, TItem> CreateNewItem { get; set; } = null!;

    [Parameter] public string CreateNewItemText { get; set; }= "Lägg till";
    
    [Parameter]
    public RenderFragment<ObservableCollection<TItem>> ItemsTemplate { get; set; } = null!;

    [Parameter]
    public RenderFragment LoadingTemplate { get; set; } = __builder =>
    {
        <LoadingIndicator Status="@LoadStatus.Loading"/>
    };

    [Parameter]
    public RenderFragment NotFoundTemplate { get; set; } = __builder =>
    {
        <p>Kunde inte hitta resurs</p>
    };

    private ObservableCollection<TItem>? _items;

    private HttpStatusCode? _responseStatus;

    protected override async Task OnInitializedAsync()
    {
        _items = null;
        _responseStatus = null;

        HttpResponseMessage response = await _http.GetAsync(Url);
        if (response.StatusCode == HttpStatusCode.OK)
        {
            var serializerOptions = new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Auto
            };

            string json = await response.Content.ReadAsStringAsync();
            _items = JsonConvert.DeserializeObject<ObservableCollection<TItem>>(json, serializerOptions);

            if (_items is not null)
                _items.CollectionChanged += ItemsCollectionChanged;

            return;
        }
        _responseStatus = response.StatusCode;
    }

    private async void ItemsCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        switch (e.Action)
        {
            case NotifyCollectionChangedAction.Add:
                await ItemsAdded(e.NewItems);
                break;
            case NotifyCollectionChangedAction.Remove:

                break;
            case NotifyCollectionChangedAction.Replace:
                break;
            case NotifyCollectionChangedAction.Move:
                break;
            case NotifyCollectionChangedAction.Reset:
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private async Task ItemsAdded(IList? items)
    {
        if (items is null) return;
        foreach (TItem addedItem in items)
            await UploadNewItem(addedItem);
    }

    private async Task UploadNewItem(TItem item)
    {
        string json = JsonConvert.SerializeObject(item,
            new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.Auto });
        var content = new StringContent(json, Encoding.UTF8, "application/json");

        string saveTaskName = $"{typeof(TItem).Name}-UploadNew";
        await SetSaving.InvokeAsync((saveTaskName, LoadStatus.Loading));
        HttpResponseMessage response = await _http.PutAsync(Url, content);
        if (response.IsSuccessStatusCode)
            await SetSaving.InvokeAsync((saveTaskName, LoadStatus.Success));
        else
            await SetSaving.InvokeAsync((saveTaskName, LoadStatus.Fail));
    }


}